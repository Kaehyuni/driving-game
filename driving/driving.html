<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Parallel Parking — Vertical Right Bay (Slim + Lane Lines)</title>
<style>
  :root { --bg:#0c1220; --lot:#1e2a44; --text:#eef2ff; --accent:#e9e370; --ok:#5df2a2; --bad:#ff5d7a; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:grid;gap:12px;place-items:center;padding:14px;max-width:1100px;margin:0 auto}
  h1{font-size:clamp(18px,2.6vw,28px);margin:8px 0 0;font-weight:700;letter-spacing:.3px;text-align:center}
  .hud{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;font-size:14px;opacity:.95}
  .stat{background:#0e162b;padding:6px 10px;border-radius:8px;border:1px solid #243255}
  canvas{width:min(100%,1000px);height:auto;aspect-ratio:16/10;background:var(--lot);border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,.45),inset 0 0 0 2px #101a31}
  .controls{display:grid;grid-template-columns:repeat(5,minmax(72px,1fr));gap:10px;width:min(100%,1000px)}
  button{background:#0e162b;color:var(--text);border:1px solid #2b3a65;border-radius:10px;padding:12px;font-size:14px;font-weight:600;letter-spacing:.2px;box-shadow:inset 0 0 0 1px #101a31;touch-action:manipulation}
  button:active{transform:translateY(1px)}
  .go{background:#0f2b1d;border-color:#2c5b44}
  .rev{background:#2b1010;border-color:#5b2c2c}
  .brk{background:#2b1810;border-color:#5b3b2c}
  .rst{background:#101d2b;border-color:#2c465b}
  .hint{opacity:.8;font-size:12px;text-align:center;margin-top:-6px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Parallel Parking — Reverse into the Slim Middle Bay</h1>
    <div class="hud">
      <div class="stat">Speed: <span id="spd">0.00</span> m/s</div>
      <div class="stat">Steer: <span id="steer">0°</span></div>
      <div class="stat">Status: <span id="status">Start left of the lower car. Reverse into middle bay.</span></div>
    </div>
    <canvas id="game" width="1000" height="625"></canvas>
    <div class="controls">
      <button id="left" aria-label="Left">◀︎ Left</button>
      <button id="fwd" class="go" aria-label="Forward">▲ Forward</button>
      <button id="brk" class="brk" aria-label="Brake">■ Brake</button>
      <button id="rev" class="rev" aria-label="Reverse">▼ Reverse</button>
      <button id="right" aria-label="Right">Right ▶︎</button>
      <button id="reset" class="rst" style="grid-column: span 5;">↺ Reset</button>
    </div>
    <div class="hint">Keys: W/↑ forward, S/↓ reverse, A/← left, D/→ right, Space brake, R reset</div>
  </div>

<script>
// ====== Setup ======
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const spdEl = document.getElementById('spd');
const steerEl = document.getElementById('steer');
const statusEl = document.getElementById('status');

const keys = new Set();
['keydown','keyup'].forEach(ev=>window.addEventListener(ev, e=>{
  const t=e.type==='keydown';
  const k=e.key.toLowerCase();
  if(t) keys.add(k); else keys.delete(k);
}));

const btn = id=>document.getElementById(id);
const btnState = {left:false,right:false,fwd:false,rev:false,brk:false};
function bindHold(el, key){
  const d=()=>btnState[key]=true, u=()=>btnState[key]=false;
  el.addEventListener('mousedown',d); el.addEventListener('touchstart',e=>{e.preventDefault();d();},{passive:false});
  ['mouseup','mouseleave','touchend','touchcancel'].forEach(x=>el.addEventListener(x,u));
}
['left','right','fwd','rev','brk'].forEach(id=>bindHold(btn(id), id));
btn('reset').addEventListener('click', resetGame);
window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='r') resetGame(); });

// ====== World Geometry (right-side vertical bay, slimmer & lane lines) ======
const W = canvas.width, H = canvas.height;
const curb = {x:40, y:40, w:W-80, h:H-80, r:18};

// Right bay frame — thinner overall width
const bay = {
  x: curb.x + curb.w - 200, // slightly farther left than before to thin the bay area
  y: curb.y + 20,
  w: 140,                   // narrower bay
  h: curb.h - 40,
  bar: 18                   // rail thickness
};

// Inner width between rails
const innerW = bay.w - 2*bay.bar;

// Middle slot fully inside rails (narrower)
const slot = {
  x: bay.x + bay.bar,
  y: bay.y + bay.bar + 160,
  w: innerW,
  h: 250,
  angle: Math.PI/2
};

// Margins so grey cars sit fully behind yellow rails
const sidePad = 12;   // left/right gap inside rails
const endPad  = 12;   // gap to dividers/top/bottom

// Sections above and below slot (inside rails)
const topStart    = bay.y + bay.bar;
const topEnd      = slot.y - bay.bar;
const bottomStart = slot.y + slot.h + bay.bar;
const bottomEnd   = bay.y + bay.h - bay.bar;

const topSectionH    = Math.max(0, topEnd - topStart);
const bottomSectionH = Math.max(0, bottomEnd - bottomStart);

// Parked cars (rotate 90°). h is the cross-car width; w is the length along bay
const parkedWidth = Math.max(40, innerW - 2*sidePad); // SLIM and within rails
const parkedTopLen = Math.max(80, topSectionH - 2*endPad);
const parkedBotLen = Math.max(80, bottomSectionH - 2*endPad);

const parked = [
  { // TOP car — up high for entry clearance
    x: slot.x + sidePad,
    y: topStart + endPad,
    w: parkedTopLen,
    h: parkedWidth,
    angle: Math.PI/2
  },
  { // BOTTOM car — low, near bottom rail
    x: slot.x + sidePad,
    y: bottomStart + endPad,
    w: parkedBotLen,
    h: parkedWidth,
    angle: Math.PI/2
  }
];

// ====== Player Car (slim) ======
const car = {
  length: 120, width: 50, wheelbase: 82,
  x: bay.x - 80, // a bit closer to the bay per your last tweak
  y: parked[1].y + parked[1].h/2,
  angle: -Math.PI/2, // facing UP
  speed: 0, steer: 0,
  maxSteer: 32*Math.PI/180, steerRate: 180*Math.PI/180,
  accel: 220, maxSpeedF: 240, maxSpeedR: 160,
  friction: 1.2, brakeDecel: 500
};

function resetGame(){
  car.x = bay.x - 80;
  car.y = parked[1].y + parked[1].h/2;
  car.angle = -Math.PI/2; // up
  car.speed = 0; car.steer = 0; gameOver=false; parkedClean=false;
  statusEl.textContent = 'Start left of the lower car. Reverse into middle bay.';
}

// ====== Sim ======
let last = performance.now();
const dtClamp = 1/50;
let gameOver=false, parkedClean=false;

function input(){
  const left = btnState.left || keys.has('a') || keys.has('arrowleft');
  const right = btnState.right || keys.has('d') || keys.has('arrowright');
  const fwd = btnState.fwd || keys.has('w') || keys.has('arrowup');
  const rev = btnState.rev || keys.has('s') || keys.has('arrowdown');
  const brk = btnState.brk || keys.has(' ');
  return {left,right,fwd,rev,brk};
}
const clamp=(v,mi,ma)=>Math.max(mi,Math.min(ma,v));
const normAngle=a=>{a%=2*Math.PI; if(a<0)a+=2*Math.PI; return a;};

function update(dt){
  if(gameOver) return;
  const {left,right,fwd,rev,brk} = input();

  const steerScale = 0.75 + 0.25*Math.min(1, Math.abs(car.speed)/120);
  if(left) car.steer -= car.steerRate*steerScale*dt;
  if(right) car.steer += car.steerRate*steerScale*dt;
  car.steer = clamp(car.steer, -car.maxSteer, car.maxSteer);

  if(fwd && !rev) car.speed += car.accel*dt;
  if(rev && !fwd) car.speed -= car.accel*dt;
  car.speed = clamp(car.speed, -car.maxSpeedR, car.maxSpeedF);

  const sgn=Math.sign(car.speed); const mag=Math.max(0,Math.abs(car.speed)-car.friction*dt); car.speed = mag*sgn;
  if(brk){ const s=Math.sign(car.speed); car.speed -= s*car.brakeDecel*dt; if(Math.sign(car.speed)!==s) car.speed=0; }

  const L=car.wheelbase;
  car.x += car.speed*Math.cos(car.angle)*dt;
  car.y += car.speed*Math.sin(car.angle)*dt;
  car.angle += (car.speed/L)*Math.tan(car.steer)*dt;

  keepInsideCurb();

  for(const p of parked){
    if(rectRectOverlap(getCarRect(car), rectFromObj(p))){ gameOver=true; statusEl.textContent='Bumped a car! Tap ↺ Reset'; }
  }

  // success: fully inside slot, nearly vertical (aligned to slot angle or opposite)
  const angErr = Math.min(Math.abs(normAngle(car.angle)-slot.angle), Math.abs(normAngle(car.angle)-(slot.angle+Math.PI)));
  if(inParkingSlot() && Math.abs(car.speed)<10 && angErr < 10*Math.PI/180){ parkedClean=true; statusEl.textContent='Parked! Great job!'; }

  spdEl.textContent=(car.speed/60).toFixed(2);
  steerEl.textContent=Math.round(car.steer*180/Math.PI)+'°';
}

function keepInsideCurb(){
  const halfDiag = Math.hypot(car.length, car.width)/2 * 0.9;
  car.x = clamp(car.x, curb.x + halfDiag, curb.x + curb.w - halfDiag);
  car.y = clamp(car.y, curb.y + halfDiag, curb.y + curb.h - halfDiag);
}

// ====== Collision helpers ======
function getCarRect(c){ return {x:c.x,y:c.y,w:c.length,h:c.width,angle:c.angle}; }
function rectFromObj(o){ return {x:o.x+o.w/2,y:o.y+o.h/2,w:o.w,h:o.h,angle:o.angle||0}; }
function rectAxes(r){ const c=Math.cos(r.angle), s=Math.sin(r.angle); return [{x:c,y:s},{x:-s,y:c}]; }
function projectRect(r,ax){
  const hw=r.w/2, hh=r.h/2, c=Math.cos(r.angle), s=Math.sin(r.angle);
  const pts=[
    {x:r.x + c*hw - s*hh, y:r.y + s*hw + c*hh},
    {x:r.x - c*hw - s*hh, y:r.y - s*hw + c*hh},
    {x:r.x + c*hw + s*hh, y:r.y + s*hw - c*hh},
    {x:r.x - c*hw + s*hh, y:r.y - s*hw - c*hh},
  ];
  let mn=Infinity,mx=-Infinity; for(const p of pts){ const pr=p.x*ax.x+p.y*ax.y; if(pr<mn)mn=pr; if(pr>mx)mx=pr; } return [mn,mx];
}
function rectRectOverlap(a,b){ const axes=[...rectAxes(a),...rectAxes(b)]; for(const ax of axes){ const [a0,a1]=projectRect(a,ax); const [b0,b1]=projectRect(b,ax); if(a1<b0||b1<a0) return false;} return true; }

function inParkingSlot(){
  const r=getCarRect(car); const hw=r.w/2, hh=r.h/2, c=Math.cos(r.angle), s=Math.sin(r.angle);
  const pts=[
    {x:r.x + c*hw - s*hh, y:r.y + s*hw + c*hh},
    {x:r.x - c*hw - s*hh, y:r.y - s*hw + c*hh},
    {x:r.x + c*hw + s*hh, y:r.y + s*hw - c*hh},
    {x:r.x - c*hw + s*hh, y:r.y - s*hw - c*hh},
  ];
  const x0=slot.x, x1=slot.x+slot.w, y0=slot.y, y1=slot.y+slot.h;
  return pts.every(p=>p.x>=x0 && p.x<=x1 && p.y>=y0 && p.y<=y1);
}

// ====== Drawing ======
function draw(){
  ctx.clearRect(0,0,W,H);
  drawRoundedRect(curb.x,curb.y,curb.w,curb.h,18,'#15203a');
  ctx.strokeStyle='#0b1326'; ctx.lineWidth=3; ctx.strokeRect(curb.x+1.5,curb.y+1.5,curb.w-3,curb.h-3);

  // driving lane markers and no-cross yellow line
  drawLaneMarkers();

  // Yellow bay frame and dividers
  drawBay();

  // Target slot box (slimmer)
  ctx.fillStyle='rgba(93,242,162,0.12)'; ctx.fillRect(slot.x,slot.y,slot.w,slot.h);
  ctx.strokeStyle = parkedClean? '#5df2a2' : (gameOver? '#ff5d7a' : '#b3c7ff');
  ctx.lineWidth=4; ctx.strokeRect(slot.x,slot.y,slot.w,slot.h);

  // Parked cars (slim)
  for(const p of parked) drawStaticCar(p);

  // Player car (slim)
  drawCar(car);
}

function drawLaneMarkers(){
  const left = curb.x + 16;
  const right = bay.x - 12; // leave a gutter near the bay
  const top = curb.y + 14;
  const bottom = curb.y + curb.h - 14;
  const w = right - left;

  // Grey dashed lane markers
  const greyLines = 4; // how many light-grey dashed lines
  ctx.setLineDash([8, 14]);
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(255,255,255,.18)';
  for(let i=1;i<=greyLines;i++){
    const x = left + (i/(greyLines+1)) * w;
    ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, bottom); ctx.stroke();
  }

  // Yellow do-not-cross line (place near middle of driving area)
  const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#ffd94a';
  const yellowX = left + 0.48 * w; // approx center-left as in your mockup
  ctx.strokeStyle = accent; ctx.lineWidth = 4; ctx.setLineDash([10, 14]);
  ctx.beginPath(); ctx.moveTo(yellowX, top); ctx.lineTo(yellowX, bottom); ctx.stroke();
  ctx.setLineDash([]);
}

function drawBay(){
  const y=bay.y, x=bay.x, w=bay.w, h=bay.h, b=bay.bar; ctx.save();
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#e9e370';
  // frame rails
  ctx.fillRect(x, y, w, b); // top
  ctx.fillRect(x, y + h - b, w, b); // bottom
  ctx.fillRect(x, y, b, h); // left rail
  ctx.fillRect(x + w - b, y, b, h); // right rail
  // dividers around middle slot
  ctx.fillRect(x, slot.y - b, w, b);
  ctx.fillRect(x, slot.y + slot.h, w, b);
  ctx.restore();
}

function drawRoundedRect(x,y,w,h,r,fill){
  ctx.beginPath(); ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath(); ctx.fillStyle=fill; ctx.fill();
}

function drawStaticCar(o){
  ctx.save(); ctx.translate(o.x + o.w/2, o.y + o.h/2); ctx.rotate(o.angle||0);
  ctx.fillStyle = '#9aa6b2'; ctx.strokeStyle='#d0d6db';
  roundRect(-o.w/2, -o.h/2, o.w, o.h, 12, true, true);
  ctx.fillStyle = 'rgba(0,0,0,.18)';
  ctx.fillRect(-o.w*0.30, -o.h*0.40, o.w*0.60, o.h*0.80); // windows, slimmer
  ctx.restore();
}

function drawCar(c){
  ctx.save(); ctx.translate(c.x,c.y); ctx.rotate(c.angle);
  // shadow
  ctx.fillStyle='rgba(0,0,0,.25)'; roundRect(-c.length/2+2,-c.width/2+6,c.length-4,c.width-4,10,true,false);
  // body
  const stroke=gameOver?'#ff5d7a':'#2e4b86'; const fill=gameOver?'rgba(255,93,122,.12)':'#15315f';
  ctx.strokeStyle=stroke; ctx.lineWidth=2; roundRect(-c.length/2,-c.width/2,c.length,c.width,10,true,true);
  ctx.fillStyle=fill; ctx.fillRect(-c.length*0.15,-c.width*0.32,c.length*0.3,c.width*0.64);
  // wheels
  const ax=c.wheelbase/2, whL=24, whW=10; ctx.fillStyle='#0a0a0a';
  ctx.fillRect(-ax - whL/2, -c.width/2-2, whL, whW);
  ctx.fillRect(-ax - whL/2,  c.width/2-whW+2, whL, whW);
  ctx.save(); ctx.translate(ax,0); ctx.rotate(c.steer);
  ctx.fillRect(-whL/2, -c.width/2-2, whL, whW);
  ctx.fillRect(-whL/2,  c.width/2-whW+2, whL, whW);
  ctx.restore();
  ctx.restore();
}

function roundRect(x,y,w,h,r,fill,stroke){
  ctx.beginPath(); ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke();
}

// ====== Loop ======
function loop(t){ const dt=Math.min((t-last)/1000, dtClamp); last=t; update(dt); draw(); requestAnimationFrame(loop); }
resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
